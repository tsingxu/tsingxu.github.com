<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../stylesheets/print.css" media="print" />
	
    <title>TsingXu's Blog</title>
	<script>
		function pageScroll(){
			window.scrollBy(0,-100);//把内容滚动指定的像素数（第一个参数是向右滚动的像素数，第二个参数是向下滚动的像素数）
			scrolldelay = setTimeout('pageScroll()',10);//延时递归调用，模拟滚动向上效果
			var sTop=document.documentElement.scrollTop+document.body.scrollTop;//获取scrollTop值，声明了DTD的标准网页取document.documentElement.scrollTop，否则取document.body.scrollTop；因为二者只有一个会生效，另一个就恒为0，所以取和值可以得到网页的真正的scrollTop值
			if(sTop==0) clearTimeout(scrolldelay);//判断当页面到达顶部，取消延时代码（否则页面滚动到顶部会无法再向下正常浏览页面）
		}
	</script>
  </head>

  <body>
	<a name='top'></a>
    <header>
      <div class="container">
        <h1>Tsingxu.github.com</h1>
        <h2></h2>

        <section id="downloads">
          <a href="https://github.com/tsingxu" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
		<a href="../"><p>Home</p></a>
      </div>
    </header>

    <div class="container">
      <section id="main_content" >
        <pre>'''
Created on Dec 10, 2012

@author: x00199331
'''
def dijkstra(graph, s):
    dis = [graph[s][i] for i in range(0, len(graph))]
    flag = [0 for i in range(0, len(graph))]
    
    for i in range(0, len(graph)):
        selected = -1;
        max_weight = 1E8;
        
        for j in range(0, len(graph)):
            if (flag[j] == 0) and (dis[j] &lt; max_weight):
                max_weight = dis[j]
                selected = j
        if selected != -1:
            flag[selected] = 1
            for j in range(0, len(graph)):
                if  j != selected:
                    if dis[j] &gt; dis[selected] + graph[selected][j]:
                        dis[j] = dis[selected] + graph[selected][j]
    return dis

图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
图的存储用的是邻接矩阵，extractMin用的是O(n)的遍历，复杂度为O(n^2)，优化点包括extractMin和存储的数据结构。extractMin可参考最小堆，数据结构可根据边的多少，如果边比较少的话可使用邻接链表，较多的话可直接使用邻接矩阵。前者的优化会有更大的空间。
	</pre>
      </section>
    </div>
	
	<div align="right">&nbsp<a onclick="pageScroll()">返回顶部</a><hr><p style="font-size:11pt;font-weight:bold;">&copy;2013 Tsingxu</p></div>
  </body>
</html>


